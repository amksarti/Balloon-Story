<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="./manifest.json">
    <title>Balloon Story</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@900&display=swap');
        body { margin: 0; padding: 0; overflow: hidden; background: #87CEEB; transition: background 3s ease; font-family: 'Nunito', sans-serif; touch-action: none; width: 100vw; height: 100vh; position: fixed; }
        canvas { display: block; position: absolute; top: 0; left: 0; }
        #ui { position: absolute; top: 8%; left: 0; width: 100%; text-align: center; pointer-events: none; color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 10; }
        #title { font-size: 1.1rem; letter-spacing: 2px; font-weight: 900; text-transform: uppercase; opacity: 0.9; }
        #score-container { line-height: 1; margin-top: 2px;}
        #current-score { font-size: 4.8rem; font-family: 'Fredoka One', cursive; display: block; }
        #best-score { font-size: 1.1rem; opacity: 0.8; margin-top: 2px; display: block; }
        #menu-btn { position: absolute; bottom: 10%; left: 5%; background: rgba(255,255,255,0.2); color: white; padding: 10px 18px; border-radius: 50px; border: 1px solid rgba(255,255,255,0.3); font-size: 0.8rem; font-weight: 900; text-transform: uppercase; pointer-events: auto; display: none; z-index: 25; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); cursor: pointer; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: radial-gradient(circle, rgba(0,0,0,0.2) 0%, rgba(0,0,0,0.5) 100%); color: white; z-index: 30; text-align: center; backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); }
        .game-title { font-family: 'Fredoka One', cursive; font-size: 3.2rem; letter-spacing: 1px; margin: 0; text-shadow: 0 6px 12px rgba(0,0,0,0.3); }
        .btn { background: linear-gradient(180deg, #5DADE2 0%, #2E86C1 100%); color: white; padding: 18px 60px; border-radius: 50px; font-weight: 900; text-transform: uppercase; letter-spacing: 1px; margin-top: 25px; pointer-events: auto; border: none; font-size: 1.4rem; box-shadow: 0 5px 0 #1B4F72, 0 10px 20px rgba(0,0,0,0.2); transition: all 0.1s; cursor: pointer; }
        .btn:active { transform: translateY(3px); box-shadow: 0 2px 0 #1B4F72, 0 5px 10px rgba(0,0,0,0.2); }
        #milestone-pop { position: absolute; top: 30%; width: 100%; text-align: center; color: #FFD700; font-family: 'Fredoka One', cursive; font-size: 2.2rem; text-transform: uppercase; letter-spacing: 3px; opacity: 0; transition: opacity 0.6s, transform 0.6s; z-index: 15; pointer-events: none; transform: scale(0.8); }
        .toggle-box { margin-top: 25px; background: rgba(255,255,255,0.08); padding: 12px 25px; border-radius: 100px; pointer-events: auto; font-size: 1rem; font-weight: 700; text-transform: uppercase; border: 1px solid rgba(255,255,255,0.2); }
        input[type="checkbox"] { transform: scale(1.6); margin-right: 12px; vertical-align: middle; cursor: pointer; }
    </style>
</head>
<body>
    <div id="ui"><div id="title">Park Wanderer</div><div id="score-container"><span id="current-score">0</span><span id="best-score">Best: 0</span></div></div>
    <button id="menu-btn" onclick="endGameManually()">Menu</button>
    <div id="start-overlay" class="overlay"><h1 class="game-title">BALLOON STORY</h1><p style="opacity: 0.8; font-size: 1.1rem; margin-top: 8px;">Tap to play</p><div class="toggle-box"><label><input type="checkbox" id="god-toggle"> Invincible</label></div><button class="btn" onclick="startGame()">Play</button></div>
    <div id="gameover-overlay" class="overlay" style="display: none;"><h1 class="game-title" style="color: #FADBD8;">GAME OVER</h1><p id="final-stats" style="margin: 15px 0; font-size: 1.2rem; font-weight: 700;"></p><button class="btn" onclick="resetToStart()">Try Again</button></div>
    <div id="milestone-pop">URBAN VOYAGER</div>
    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('current-score');
    const bestEl = document.getElementById('best-score');
    const titleEl = document.getElementById('title');
    const milestonePop = document.getElementById('milestone-pop');
    const godToggle = document.getElementById('god-toggle');
    const menuBtn = document.getElementById('menu-btn');

    const GRAV_TIERS = [0.24, 0.22, 0.20, 0.18, 0.12];
    const TAP_POWER = -8.8;
    const MILESTONES = [15, 35, 60, 100]; 
    const STAGE_NAMES = ["Park Wanderer", "Urban Voyager", "Peak Seeker", "Astronaut", "Exosphere"];

    let width, height, balloon, score, gameState, gravity, currentGroundY;
    let backdrops = [], clouds = [], stars = [], obstacles = [], decor = [], fragments = [], shieldItem = null;
    let hasShield = false, lastBiome = 0, birdSpawnTimer = 0, shieldSpawnTimer = 0, shakeTimer = 0, popTimer = 0;
    let streak = 0, isOnFire = false, squishTimer = 0, framesSinceLastTap = 0;

    let wind = { phase: 0, timer: 0, warmupTimer: 50, force: 0, visualX: 0, lastScoreBaseline: 0, triggerDistance: 8 };
    
    // --- BALANCED GALE HEAT (Triggered in ~3-4 taps) ---
    let gale = { heat: 0, maxHeat: 100, buildRate: 0.8, drainRate: 0.4, opacity: 0 };
    
    let highScore = localStorage.getItem('balloonHighScore') || 0;

    function init() {
        width = window.innerWidth; height = window.innerHeight;
        canvas.width = width; canvas.height = height;
        currentGroundY = height * 0.88;
        gameState = 'START';
        balloon = { x: width/2, y: height/2, radius: Math.min(width, height)*0.08, vx: 0, vy: 0, color: '#FF5F5F' };
        backdrops = []; clouds = []; stars = []; obstacles = []; decor = []; fragments = []; shieldItem = null;
        score = 0; lastBiome = 0; gravity = GRAV_TIERS[0]; hasShield = false; shakeTimer = 0; popTimer = 0;
        streak = 0; isOnFire = false; squishTimer = 0; framesSinceLastTap = 0;
        wind.phase = 0; wind.timer = 0; wind.force = 0; wind.visualX = 0; wind.lastScoreBaseline = 0;
        wind.triggerDistance = 7 + Math.floor(Math.random() * 5);
        
        gale.heat = 0; gale.opacity = 0;

        document.body.style.background = "#87CEEB";
        scoreEl.innerText = "0"; bestEl.innerText = `Best: ${highScore}`;
        titleEl.innerText = STAGE_NAMES[0]; menuBtn.style.display = 'none';
        for(let i=0; i<15; i++) spawnItem(true); 
        for(let i=0; i<10; i++) spawnCloud(true);
        for(let i=0; i<60; i++) stars.push({x: Math.random()*width, y: Math.random()*height, s: Math.random()*1.5});
    }

    function startGame() { gameState = 'PLAYING'; document.getElementById('start-overlay').style.display = 'none'; menuBtn.style.display = 'block'; }
    function resetToStart() { document.getElementById('gameover-overlay').style.display = 'none'; init(); document.getElementById('start-overlay').style.display = 'flex'; }
    function triggerMilestone(text) { milestonePop.innerText = text; milestonePop.style.opacity = 1; milestonePop.style.transform = "scale(1)"; setTimeout(() => { milestonePop.style.opacity = 0; milestonePop.style.transform = "scale(0.8)"; }, 2500); }

    function gameOver() {
        if (godToggle.checked) return;
        gameState = 'POPPING'; popTimer = 40; shakeTimer = 15; menuBtn.style.display = 'none';
        for(let i=0; i<8; i++) { fragments.push({ x: balloon.x, y: balloon.y, vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10, r: 4 + Math.random() * 6 }); }
    }

    function showGameOverUI() { gameState = 'GAMEOVER'; document.getElementById('gameover-overlay').style.display = 'flex'; document.getElementById('final-stats').innerText = `Score: ${score} | Region: ${titleEl.innerText}`; }
    function endGameManually() { gameState = 'GAMEOVER'; menuBtn.style.display = 'none'; document.getElementById('gameover-overlay').style.display = 'flex'; document.getElementById('final-stats').innerText = `Stopped at Score: ${score}`; }

    function spawnItem(randomX = false) {
        let type = "hill"; if (score >= MILESTONES[0]) type = "building"; if (score >= MILESTONES[1]) type = "mountain"; if (score >= MILESTONES[2]) return; 
        let itemW = type === "hill" ? 220 + Math.random()*150 : (type === "mountain" ? 300 + Math.random()*400 : 75 + Math.random()*60);
        let itemH = type === "hill" ? 30 + Math.random()*25 : (type === "mountain" ? 200 + Math.random()*250 : 250 + Math.random()*350);
        backdrops.push({ x: randomX ? Math.random() * (width + 600) : width + 400, type: type, w: itemW, h: itemH, speed: type === "mountain" ? 1.2 : 1.6 });
        if (type === "hill" && Math.random() > 0.4) { decor.push({ x: randomX ? Math.random() * (width + 600) : width + 400, type: 'tree', w: 15 + Math.random()*10, h: 40 + Math.random()*30, speed: 1.6 }); }
    }

    function spawnCloud(randomX = false) { clouds.push({ x: randomX ? Math.random() * (width + 300) : width + 200, y: Math.random() * (height * 0.5), size: 40 + Math.random() * 60, speed: 0.2 + Math.random() * 0.6, alpha: 0.1 + Math.random() * 0.3 }); }
    
    function spawnObstacle() { 
        const side = Math.random() > 0.5 ? -50 : width + 50; 
        let type = score >= MILESTONES[2] ? "satellite" : (score >= MILESTONES[1] ? "eagle" : "bird"); 
        let speed = (side < 0 ? 1 : -1) * (2.8 + (score/40)); 
        obstacles.push({ x: side, y: Math.random() * (currentGroundY - 100), vx: speed, type: type, wing: 0 }); 
    }

    function spawnShield() { if (hasShield || shieldItem) return; shieldItem = { x: 50 + Math.random() * (width - 100), y: -50, vy: 1.8 }; }

    function handleInput(posX, posY) {
        if (gameState !== 'PLAYING') return;
        const dist = Math.sqrt((posX - balloon.x)**2 + (posY - balloon.y)**2);
        if (dist < balloon.radius + 85) {
            balloon.vy = TAP_POWER; balloon.vx = (balloon.x - posX) * 0.45;
            score++; scoreEl.innerText = score;
            streak++; framesSinceLastTap = 0; squishTimer = 12;
            if (streak >= 12 && !isOnFire) { isOnFire = true; triggerMilestone("BOOST"); }
            if (!godToggle.checked && score > highScore) { highScore = score; localStorage.setItem('balloonHighScore', highScore); bestEl.innerText = `Best: ${highScore}`; }
        }
    }

    window.addEventListener('touchstart', (e) => { handleInput(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
    window.addEventListener('mousedown', (e) => { handleInput(e.clientX, e.clientY); });
    window.addEventListener('keydown', (e) => { if (e.code === 'Space' && gameState === 'START') startGame(); if (e.code === 'KeyM' && gameState === 'PLAYING') endGameManually(); });

    function update() {
        if (gameState === 'POPPING') { popTimer--; fragments.forEach(f => { f.x += f.vx; f.y += f.vy; f.vy += 0.2; }); if (popTimer <= 0) showGameOverUI(); }

        if (gameState === 'PLAYING') {
            let b = 0; if (score >= MILESTONES[0]) b = 1; if (score >= MILESTONES[1]) b = 2; if (score >= MILESTONES[2]) b = 3; if (score >= MILESTONES[3]) b = 4;
            if (b !== lastBiome) { lastBiome = b; backdrops = []; decor = []; for(let i=0; i<12; i++) spawnItem(true); document.body.style.background = ["#87CEEB", "#4A90E2", "#1A2B44", "#0A0A1A", "#050505"][b]; titleEl.innerText = STAGE_NAMES[b]; gravity = GRAV_TIERS[b]; triggerMilestone(STAGE_NAMES[b]); }

            backdrops.forEach(b => b.x -= b.speed); decor.forEach(d => d.x -= d.speed); clouds.forEach(c => c.x -= c.speed);
            framesSinceLastTap++; if (framesSinceLastTap > 150) { isOnFire = false; streak = 0; }
            if (squishTimer > 0) squishTimer--;

            // --- ULTRA-STRONG 5% CHAOS GALE ---
            if (balloon.y < height * 0.05) {
                gale.heat = Math.min(gale.maxHeat, gale.heat + gale.buildRate);
            } else {
                gale.heat = Math.max(0, gale.heat - gale.drainRate);
            }

            if (gale.heat >= gale.maxHeat) {
                balloon.vy += 0.85; // Heavy Downward Pressure
                balloon.vx += (Math.random() - 0.5) * 5.0; // Erratic Jitter
                shakeTimer = Math.max(shakeTimer, 4);
            } else if (gale.heat > 25) {
                gale.opacity = (gale.heat - 25) / 75 * 0.55; 
            } else {
                gale.opacity = 0;
            }

            if (wind.phase === 0) { 
                if (score - wind.lastScoreBaseline >= wind.triggerDistance) {
                    wind.phase = 1; wind.timer = wind.warmupTimer;
                    let isSpace = score >= MILESTONES[2];
                    wind.force = (Math.random() > 0.5 ? 1 : -1) * (isSpace ? 3.2 : 1.8);
                    wind.visualX = 0; 
                }
            } else if (wind.phase === 1) { 
                shakeTimer = 2; wind.timer--;
                wind.visualX += wind.force * 6;
                if (wind.timer <= 0) { wind.phase = 2; let isSpace = score >= MILESTONES[2]; wind.timer = isSpace ? 110 : 230; shakeTimer = 22; }
            } else if (wind.phase === 2) { 
                balloon.vx += wind.force * 0.05; wind.timer--; wind.visualX += wind.force * 18;
                if (wind.timer <= 0) { wind.phase = 0; wind.lastScoreBaseline = score; wind.triggerDistance = 7 + Math.floor(Math.random() * 5); }
            }

            balloon.vy += gravity; balloon.y += balloon.vy; balloon.x += balloon.vx; 
            balloon.vx *= (wind.phase > 0) ? 0.98 : 0.92;
            if (balloon.x < balloon.radius) { balloon.x = balloon.radius; balloon.vx = Math.abs(balloon.vx) * 0.5 + 1.2; }
            if (balloon.x > width - balloon.radius) { balloon.x = width - balloon.radius; balloon.vx = -(Math.abs(balloon.vx) * 0.5 + 1.2); }
            if (score >= MILESTONES[2] && currentGroundY < height * 0.94) currentGroundY += 3;
            
            birdSpawnTimer++; if (birdSpawnTimer > Math.max(35, 140 - score*2.5)) { spawnObstacle(); birdSpawnTimer = 0; }
            shieldSpawnTimer++; const sThreshold = hasShield ? 600 : Math.max(80, 400 - score * 12); if (shieldSpawnTimer > sThreshold) { spawnShield(); shieldSpawnTimer = 0; }

            obstacles.forEach((o, i) => {
                o.x += o.vx; o.wing += 0.15;
                let d = Math.sqrt((balloon.x-o.x)**2 + (balloon.y-o.y)**2);
                if (d < balloon.radius + 15) { 
                    if (isOnFire) { isOnFire = false; streak = 0; shakeTimer = 25; obstacles.splice(i, 1); }
                    else if (hasShield) { hasShield = false; streak = 0; shakeTimer = 15; obstacles.splice(i, 1); } 
                    else { gameOver(); }
                }
                if (o.x < -250 || o.x > width + 250) obstacles.splice(i, 1);
            });
            if (shieldItem) {
                shieldItem.y += 1.8; let d = Math.sqrt((balloon.x-shieldItem.x)**2 + (balloon.y-shieldItem.y)**2);
                if (d < balloon.radius + 20) { hasShield = true; shieldItem = null; } else if (shieldItem.y > height) shieldItem = null;
            }
            if (balloon.y + balloon.radius > currentGroundY) { balloon.y = currentGroundY - balloon.radius; balloon.vy = -Math.abs(balloon.vy) * 0.5; streak = 0; isOnFire = false; }
            let rmost = 0; backdrops.forEach(b => { if(b.x + b.w > rmost) rmost = b.x + b.w; });
            if (rmost < width + 100) spawnItem();
        }
        if (shakeTimer > 0) shakeTimer--; draw(); requestAnimationFrame(update);
    }

    function draw() {
        ctx.save(); if (shakeTimer > 0) ctx.translate(Math.random()*10-5, Math.random()*10-5); ctx.clearRect(0, 0, width, height);
        
        clouds.forEach(c => { ctx.fillStyle = `rgba(255, 255, 255, ${c.alpha})`; ctx.beginPath(); ctx.arc(c.x, c.y, c.size, 0, Math.PI*2); ctx.fill(); });
        if (score >= MILESTONES[0]) { ctx.fillStyle = "white"; stars.forEach(s => { ctx.globalAlpha = Math.random(); ctx.fillRect(s.x, s.y, s.s, s.s); }); ctx.globalAlpha = 1.0; }
        
        backdrops.forEach(b => {
            ctx.fillStyle = (score >= MILESTONES[0]) ? "#111" : "#2d4d2d";
            if (b.type === "hill") { ctx.beginPath(); ctx.ellipse(b.x + b.w/2, currentGroundY, b.w, b.h, 0, 0, Math.PI, true); ctx.fill(); }
            else if (b.type === "building") { ctx.fillStyle = "#222"; ctx.fillRect(b.x, currentGroundY - b.h, b.w, b.h); ctx.fillStyle = "#FFD700"; for(let r=0; r<6; r++) for(let c=0; c<2; c++) ctx.fillRect(b.x + 10 + c*25, currentGroundY - b.h + 20 + r*45, 10, 10); }
            else if (b.type === "mountain") { ctx.fillStyle = "#0a0a0a"; ctx.beginPath(); ctx.moveTo(b.x, currentGroundY); ctx.lineTo(b.x + b.w/2, currentGroundY - b.h); ctx.lineTo(b.x + b.w, currentGroundY); ctx.fill(); ctx.fillStyle = "white"; ctx.beginPath(); ctx.moveTo(b.x + b.w*0.4, currentGroundY - b.h*0.8); ctx.lineTo(b.x + b.w/2, currentGroundY - b.h); ctx.lineTo(b.x + b.w*0.6, currentGroundY - b.h*0.8); ctx.fill(); }
        });
        decor.forEach(d => { ctx.fillStyle = "#1a331a"; ctx.fillRect(d.x, currentGroundY - d.h, d.w/4, d.h); ctx.beginPath(); ctx.moveTo(d.x - d.w/2, currentGroundY - d.h*0.3); ctx.lineTo(d.x + d.w/8, currentGroundY - d.h*1.2); ctx.lineTo(d.x + d.w, currentGroundY - d.h*0.3); ctx.fill(); });

        if (wind.phase > 0 && wind.timer > 0) {
            let isp = score >= MILESTONES[2]; ctx.globalAlpha = (wind.phase === 1) ? 0.35 : 0.65;
            ctx.strokeStyle = isp ? "rgba(255, 100, 0, 1)" : "rgba(255, 255, 255, 1)"; ctx.lineWidth = isp ? 10 : 5;
            for(let i=0; i<8; i++) { let y = (height * 0.1) + i * (height * 0.1); let xS = (wind.visualX + (i * 150)) % (width + 300) - 150; ctx.beginPath(); ctx.moveTo(xS, y); ctx.lineTo(xS + (wind.force > 0 ? 150 : -150), y); ctx.stroke(); } ctx.globalAlpha = 1.0;
        }

        // --- ROUNDED RED HEAT VIGNETTE ---
        if (gale.opacity > 0) {
            let grad = ctx.createRadialGradient(width/2, height/2, width*0.1, width/2, height/2, width*0.88);
            grad.addColorStop(0, "rgba(255, 0, 0, 0)");
            grad.addColorStop(1, `rgba(255, 0, 0, ${gale.opacity})`);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);

            if (gale.heat >= gale.maxHeat) {
                let isp = score >= MILESTONES[2];
                ctx.strokeStyle = isp ? "rgba(255, 200, 0, 0.4)" : "rgba(255, 255, 255, 0.4)";
                ctx.lineWidth = 2;
                for(let i=0; i<12; i++) {
                    let x = (width * 0.08) * i + (width * 0.04);
                    let yS = (Date.now() * 2.2 + (i * 180)) % (height + 300) - 150;
                    ctx.beginPath(); ctx.moveTo(x, yS); ctx.lineTo(x, yS + 160); ctx.stroke();
                }
            }
        }

        if (score >= MILESTONES[2]) { ctx.strokeStyle = "rgba(0, 162, 255, 0.8)"; ctx.lineWidth = 15; ctx.beginPath(); ctx.arc(width/2, currentGroundY + (height*2.5), height*2.6, 0, Math.PI*2); ctx.stroke(); ctx.fillStyle = "rgba(0, 50, 150, 0.4)"; ctx.fill(); }
        if (currentGroundY < height + 50) { ctx.fillStyle = score < MILESTONES[0] ? '#4CAF50' : (score < MILESTONES[1] ? '#444' : '#0a0a0a'); ctx.fillRect(0, currentGroundY, width, height); }
        
        obstacles.forEach(o => { ctx.lineWidth = 5; ctx.strokeStyle = (score >= MILESTONES[0]) ? "white" : "#333"; if (o.type === "satellite") { ctx.strokeStyle = "#00F2FF"; ctx.fillStyle = "#888"; ctx.fillRect(o.x-15, o.y-5, 30, 10); ctx.fillStyle = "#00F2FF"; ctx.fillRect(o.x-25, o.y-8, 10, 16); ctx.fillRect(o.x+15, o.y-8, 10, 16); } else { let w = Math.sin(o.wing)*10; ctx.beginPath(); ctx.moveTo(o.x-18, o.y+w); ctx.lineTo(o.x, o.y); ctx.lineTo(o.x+18, o.y+w); ctx.stroke(); } });
        
        if (shieldItem) { let isp = score >= MILESTONES[2]; ctx.fillStyle = isp ? "#BF5AF2" : "#48C9B0"; ctx.shadowBlur = 15; ctx.shadowColor = ctx.fillStyle; ctx.beginPath(); ctx.arc(shieldItem.x, shieldItem.y, 15, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0; }
        if (gameState === 'POPPING') { ctx.fillStyle = balloon.color; fragments.forEach(f => { ctx.beginPath(); ctx.arc(f.x, f.y, f.r, 0, Math.PI*2); ctx.fill(); }); }
        
        if (gameState === 'PLAYING') {
            ctx.beginPath(); ctx.moveTo(balloon.x, balloon.y + balloon.radius); ctx.lineTo(balloon.x - (balloon.vx * 4), balloon.y + balloon.radius + 35); ctx.strokeStyle = "rgba(255, 255, 255, 0.5)"; ctx.lineWidth = 2; ctx.stroke();
            ctx.save(); ctx.translate(balloon.x, balloon.y);
            if (squishTimer > 0) { let intensity = (squishTimer / 12) * 0.15; let sY = 1 - intensity; let sX = 1 + intensity * 0.5; ctx.scale(sX, sY); }
            if (isOnFire) { ctx.shadowBlur = 25; ctx.shadowColor = "#FFA500"; ctx.fillStyle = "#FF8C00"; } else { ctx.fillStyle = balloon.color; }
            ctx.beginPath(); ctx.arc(0, 0, balloon.radius, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0; ctx.restore();
            if (hasShield) { let isp = score >= MILESTONES[2]; ctx.strokeStyle = isp ? "#BF5AF2" : "#48C9B0"; ctx.lineWidth = 6; ctx.beginPath(); ctx.arc(balloon.x, balloon.y, balloon.radius + 12, 0, Math.PI*2); ctx.stroke(); }
        }
        ctx.restore();
    }
    init(); update();
</script>

<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js')
        .then(reg => console.log('Service Worker registered!', reg))
        .catch(err => console.log('Service Worker failed:', err));
    });
  }
</script>
</body>
</html>
